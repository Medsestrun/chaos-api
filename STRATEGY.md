# Grid Bot Strategy System

## Архитектура

Система состоит из нескольких компонентов:

### 1. **MemoryStorage** (`src/MemoryStorage.ts`)
Синглтон для хранения данных стратегии в памяти:
- Информация о стратегии
- Уровни размеров ордеров (orderSizeLevels)
- Позиции
- Ордера
- **Сервисные ордера** - специальные ордера для технических операций:
  - `INITIAL_POSITIONS_BUY_UP` - начальная закупка позиций для гридов выше текущей цены
  - `FILL_EMPTY_POSITIONS` - дозакупка недостающих позиций
  - `ORDER_SIZE_INCREASE` - увеличение размеров позиций

### 2. **Strategy Loader** (`src/services/strategyLoader.ts`)
Загружает данные из базы данных в MemoryStorage:
- `loadEnabledStrategy()` - загружает первую включенную стратегию при старте
- `reloadStrategy(strategyId)` - перезагружает конкретную стратегию

### 3. **Hyperliquid Service** (`src/services/hyperliquidService.ts`)
Работает с биржей Hyperliquid:
- Подключается к WebSocket
- Получает текущую цену ETH-PERP
- Подписывается на filled события (заполнение ордеров)
- Выставляет **N BUY и N SELL ордеров** одновременно (N задается в настройках стратегии, по умолчанию 2)
- При filled событии автоматически обновляет ордера
- Синхронизирует ордера на основе текущей цены и открытых позиций

### 4. **Strategy Service** (`src/services/strategyService.ts`)
Бизнес-логика стратегии:
- `findBuyTargets(currentPrice, limit, ensureMinimum)` - находит грида для покупки (без позиций и без открытых BUY ордеров, ниже текущей цены), с fallback на любой свободный грид если ensureMinimum=true
- `findSellTargets(currentPrice, limit, ensureMinimum)` - находит позиции для продажи (без открытых SELL ордеров на эти позиции), с fallback на любую позицию если ensureMinimum=true
- `handleInitialPositionsFill(serviceOrder, fill)` - обрабатывает заполнение начального сервисного ордера
- `handleBuyOrderFill(fill)` - обрабатывает заполнение BUY ордера (создает позицию в БД)
- `handleSellOrderFill(fill)` - обрабатывает заполнение SELL ордера (закрывает позицию в БД)
- `saveOpenedOrderToDB(orderId, size, side, price, positionId)` - сохраняет открытый ордер в БД при выставлении
- `findGridUpperIndex(price)` - находит первый грид выше заданной цены
- `getOrderSizeInEth()` - конвертирует размер из USDT в ETH
- `roundPrice(price)` - округляет цену до 1 знака после запятой (BigNumber.js)
- `roundSize(size)` - округляет размер до 4 знаков после запятой (BigNumber.js)
- `getOrderIdFromStatus(status)` - извлекает ID ордера из одного статуса
- `getAllOrderIdsFromResponse(orderData)` - извлекает все ID ордеров из ответа биржи

### 5. **Strategy Runner** (`src/services/strategyRunner.ts`)
Управляет жизненным циклом стратегии:
- `start()` - запускает стратегию при старте приложения
- `enableStrategy(strategyId)` - включает конкретную стратегию
- `stop()` - останавливает текущую стратегию

## Точность вычислений

Все расчеты используют библиотеку **BigNumber.js** для высокой точности:

- **Цены (px)**: округляются **вниз** до **1 знака** после запятой (`ROUND_DOWN`)
  - Пример: `3542.47 → 3542.4`
  - Применяется при: создании грида, выставлении ордеров, сохранении в БД
- **Размеры (size)**: округляются **вниз** до **4 знаков** после запятой (`ROUND_DOWN`)
  - Пример: `0.123456 → 0.1234`
  - Применяется при: конвертации USDT→ETH, выставлении ордеров, создании позиций

**Функции округления:**

- `strategyService.roundPrice(price)` - для цен
- `strategyService.roundSize(size)` - для размеров
- `calculateGrid()` - создает грида с ценами, округленными до 1 знака

## Логика работы

### При старте приложения:
1. Подключается к Hyperliquid WebSocket
2. Загружает первую включенную стратегию из БД (только открытые ордера)
3. Ждет получения текущей цены
4. **Если нет открытых позиций (свежий старт):**
   - Выставляет 1 MARKET ордер с суммарным размером всех недостающих позиций
   - После заполнения автоматически запустится синхронизация через filled event
5. **Если есть открытые позиции:**
   - Синхронизирует ордера (N BUY + N SELL, где N из настроек стратегии)

### При включении стратегии (PATCH /strategies/:id/toggle):
1. Обновляет статус `enabled` в БД
2. Если `enabled = true`:
   - Останавливает предыдущую стратегию (если была)
   - Подключается к бирже
   - Загружает данные стратегии
   - Открывает недостающие позиции
   - Синхронизирует ордера
3. Если `enabled = false`:
   - Останавливает стратегию

### Синхронизация ордеров:
1. **Отменяет все текущие открытые ордера** (опционально)
2. Определяет количество ордеров (параметр или 1 по умолчанию)
3. Находит **N ближайших грида** ниже текущей цены для покупки:
   - **Сначала ищет грида ниже текущей цены** (приоритетные)
   - **При первом запуске** (`ensureMinimum=true`): если не нашли свободных гридов ниже текущей цены, ищет **любой** свободный грид для гарантии минимум 1 BUY ордера
   - Проверяет: нет открытой позиции на этом гриде
   - Проверяет: нет открытого BUY ордера на этой цене
   - Выставляет **N BUY ордеров** на этих уровнях (через `strategyService.findBuyTargets()`)
4. Находит **N ближайших открытых позиций** для продажи:
   - **Сначала ищет позиции ниже текущей цены** (приоритетные)
   - **При первом запуске** (`ensureMinimum=true`): если не нашли позиций ниже текущей цены, ищет **любую** доступную позицию для гарантии минимум 1 SELL ордера
   - Проверяет: нет открытого SELL ордера на эту позицию
   - Выставляет **N SELL ордеров** на следующих уровнях грида (через `strategyService.findSellTargets()`)
5. **Гарантия ликвидности:** При первом запуске гарантируется минимум 1 BUY и 1 SELL ордер, чтобы не зависнуть без трейдов, если цена пойдет в одну сторону
6. **Триггер:** Синхронизация автоматически запускается при:
   - Старте приложения (`ensureMinimum=true`)
   - Включении стратегии (`ensureMinimum=true`)
   - Заполнении любого ордера (filled event из WebSocket)

### Открытие начальных позиций (свежий старт):
При свежем старте (нет открытых позиций):
1. Находит первый грид ВЫШЕ текущей цены
2. Рассчитывает суммарный размер всех позиций для гридов ВЫШЕ текущей цены
3. Выставляет **1 LIMIT BUY ордер** с суммарным размером (сервисный ордер типа `INITIAL_POSITIONS_BUY_UP`)
4. Сохраняет сервисный ордер в памяти с метаданными (начальная цена, количество позиций)
5. **При заполнении сервисного ордера** (`handleInitialPositionsFill`):
   - Получает данные о заполнении (цена, размер в ETH, комиссия)
   - Вычисляет количество недостающих позиций (`numberOfPositions`)
   - **Делит реальный размер купленной позиции на количество гридов:**
     - `sizePerPosition = totalSizeInEth / numberOfPositions`
     - Округляет до 4 знаков после запятой с помощью `BigNumber.js`
   - Создает позиции для каждого грида выше начальной цены
   - Для каждой позиции:
     - Размер = `sizePerPosition` (в ETH)
     - `gridOpenPrice` = текущий грид
     - `gridClosePrice` = следующий грид
   - Сохраняет все позиции в БД
   - Обновляет память
   - Удаляет сервисный ордер из памяти
   - Запускает обычную синхронизацию ордеров `syncOrders()`
6. Далее работает обычная логика 2+2 ордера

### Обработка заполненных ордеров:
При получении filled события из WebSocket:

**Предварительная обработка:**
1. **Группировка fills по oid** - один ордер может иметь несколько fills (частичные заполнения)
2. **Проверка дубликатов** - если ордер уже имеет статус `FILLED`, пропускаем
3. **Агрегация данных** для каждого уникального ордера:
   - `totalSize` = сумма всех `sz`
   - `totalFee` = сумма всех `fee`
   - `avgPrice` = средневзвешенная цена: `Σ(px * sz) / totalSize`

**BUY ордер заполнен** (`handleBuyOrderFill`):
1. **Находит ордер в памяти** для получения целевой цены грида
2. **Определяет грид по целевой цене** (`order.averagePrice`), а не по фактической цене исполнения
   - ⚠️ **Важно:** LIMIT ордер может исполниться по лучшей цене, поэтому используем целевую цену грида из `order.averagePrice`
   - Пример: ордер выставлен на 3400, исполнился по 3395 → используем 3400 для определения грида
3. Находит ближайший грид ниже целевой цены (`findFirstGridLower(order.averagePrice)`)
4. Определяет цену закрытия (следующий грид вверх)
5. **Создает позицию в БД:**
   - `gridOpenPrice` - найденный грид (по целевой цене)
   - `avgOpenPrice` - **фактическая** цена заполнения (`fill.px`)
   - `gridClosePrice` - следующий грид
   - `size` - размер в ETH
   - `status` = `OPENED`
6. **Обновляет ордер в БД:**
   - Привязывает к созданной позиции (`positionId`)
   - Устанавливает `status` = `FILLED`
   - **Обновляет `averagePrice`** фактической ценой исполнения (`fill.px`)
   - Записывает комиссию
7. Обновляет баланс (вычитает комиссию)
8. Удаляет ордер из памяти
9. Добавляет позицию в память

**SELL ордер заполнен** (`handleSellOrderFill`):
1. Находит ордер в памяти по `oid`
2. Получает `positionId` из ордера
3. Находит позицию в памяти
4. **Рассчитывает PnL на основе фактических цен:**
   - `PnL = (fill.px - position.avgOpenPrice) * size`
   - Использует **фактические** цены исполнения для точного расчета прибыли
5. **Закрывает позицию в БД:**
   - Устанавливает `status` = `CLOSED`
6. **Обновляет ордер в БД:**
   - `status` = `FILLED`
   - **Обновляет `averagePrice`** фактической ценой исполнения (`fill.px`)
   - `closedPnl` = рассчитанный PnL
   - Записывает комиссию
7. Обновляет баланс (добавляет PnL, вычитает комиссию)
8. Удаляет позицию и ордер из памяти

**После обработки всех заполнений:**
- Запускается `syncOrders(ensureMinimum)` для выставления новых ордеров
- `ensureMinimum=true` если был обработан сервисный ордер начальной закупки
- Это гарантирует выставление минимум 1 BUY и 1 SELL ордера после начальной закупки

**Пример: почему важно использовать целевую цену грида:**

```
Грида: [3000, 3100, 3200, 3300, 3400, 3500]

1. Выставляем BUY ордер на грид 3400
   → Сохраняем в БД: averagePrice = 3400

2. LIMIT ордер исполняется по более выгодной цене: 3395
   → fill.px = 3395

3. Обработка fill:
   ❌ НЕПРАВИЛЬНО: использовать fill.px (3395)
      → findFirstGridLower(3395) вернет 3300
      → Позиция будет привязана к гриду 3300 (ОШИБКА!)
   
   ✅ ПРАВИЛЬНО: использовать order.averagePrice (3400)
      → findFirstGridLower(3400) вернет 3400
      → Позиция привязана к гриду 3400 (ВЕРНО!)

4. Результат:
   - gridOpenPrice = 3400 (целевой грид)
   - avgOpenPrice = 3395 (фактическая цена, лучше для PnL!)
   - gridClosePrice = 3500 (следующий грид)
```

**Пример группировки fills:**
```typescript
// WebSocket event с несколькими fills для одного ордера
fills: [
  { oid: 123, side: 'B', px: '4100', sz: '0.01', fee: '0.02' },
  { oid: 123, side: 'B', px: '4102', sz: '0.015', fee: '0.03' },
  { oid: 456, side: 'A', px: '4200', sz: '0.02', fee: '0.04' }
]

// Группируем по oid:
Map {
  123 => [fill1, fill2],  // 2 частичных заполнения одного BUY ордера
  456 => [fill3]           // 1 SELL ордер
}

// Агрегируем для oid 123:
totalSize = 0.01 + 0.015 = 0.025 ETH
totalFee = 0.02 + 0.03 = 0.05
avgPrice = (4100 * 0.01 + 4102 * 0.015) / 0.025 = 4101.2

// Обрабатываем как один BUY fill с агрегированными данными
```

**Пример свежего старта:**
- Текущая цена: 4107.25
- Гриды: [3000, 3100, ..., 5000] (70 гридов)
- Первый грид выше: 5000 (индекс 39)
- Недостающих позиций: 70 - 39 = 31 позиция
- Суммарный размер в USDT: 31 × 20 = 620 USDT
- **Действие:** Выставляет 1 LIMIT BUY ордер на 620 USDT
- **После заполнения:** Куплено, например, 0.1509 ETH
- **Размер одной позиции:** 0.1509 / 31 = 0.0048 ETH (округлено до 4 знаков)
- Создаются 31 позиция по 0.0048 ETH каждая для гридов 39-69

**Пример гарантии ликвидности при старте:**
```
Сценарий 1: Цена очень высоко, все позиции намного ниже

Текущая цена: 5200
Позиции: [3000, 3100, 3200, ..., 4900] (все далеко ниже)

Обычная логика SELL:
- findSellTargets ищет позиции НИЖЕ 5200
- Не находит (все позиции намного ниже currentGridIndex)
- Результат: 0 SELL ордеров ❌

С ensureMinimum=true (при старте):
- findSellTargets ищет позиции НИЖЕ 5200
- Не находит
- Активируется fallback: находит ЛЮБУЮ доступную позицию
- Результат: 1 SELL ордер на позицию 4900 → close at 5000 ✅

---

Сценарий 2: Цена очень низко, все грида ниже уже имеют позиции

Текущая цена: 3050
Позиции: [3000, 3100, 3200, ..., 5000] (все грида ниже 3050 уже заняты)
Свободные грида: [3100, 3200, ..., 5000] (только выше текущей цены)

Обычная логика BUY:
- findBuyTargets ищет грида НИЖЕ 3050 без позиций
- Не находит (грид 3000 имеет позицию)
- Результат: 0 BUY ордеров ❌

С ensureMinimum=true (при старте):
- findBuyTargets ищет грида НИЖЕ 3050
- Не находит свободных
- Активируется fallback: ищет ЛЮБОЙ свободный грид
- Находит грид 3100 (выше текущей цены, но без позиции)
- Результат: 1 BUY ордер на 3100 ✅

---

Итог: Гарантируется минимум 1 BUY + 1 SELL при старте
Если цена пойдет вверх → сработает SELL
Если цена пойдет вниз → сработает BUY
```

## API Endpoints

### POST /strategies
Создает новую стратегию:
```json
{
  "minPrice": 3000,
  "maxPrice": 5000,
  "numberOfGrids": 70,
  "numberOfOrders": 2,
  "margin": 1000,
  "orderSizeLevels": [
    {
      "levelStart": 3000,
      "levelEnd": 4000,
      "size": 30
    },
    {
      "levelStart": 4000,
      "levelEnd": 5000,
      "size": 20
    }
  ]
}
```

**Параметры:**
- `minPrice`, `maxPrice` - диапазон цен для грид-бота
- `numberOfGrids` - количество гридов (уровней цен)
- `numberOfOrders` - количество одновременно открытых BUY и SELL ордеров (1-10, по умолчанию 2)
- `margin` - маржа для стратегии в USDT
- `orderSizeLevels` - уровни размеров ордеров:
  - `levelStart`, `levelEnd` - это **ЦЕНЫ** (диапазон цен для этого уровня размера)
  - `levelEnd` не включается в диапазон **кроме последнего диапазона**
  - Для гридов в диапазоне [3000, 4000) будет использоваться размер 30 USDT
  - Для гридов в диапазоне [4000, 5000] будет использоваться размер 20 USDT (последний диапазон - включительно!)

**Ответ:**
```json
{
  "strategyId": "uuid"
}
```

### PATCH /strategies/:strategyId/toggle
Включает/выключает стратегию:
```json
{
  "enabled": true
}
```

**Ответ:**
```json
{
  "strategyId": "uuid",
  "enabled": true
}
```

### GET /
Проверка статуса API:
```json
{
  "message": "Chaos API is running",
  "strategyRunning": true
}
```

## Настройка окружения

Создайте `.env` файл с необходимыми переменными:
```env
PRIVATE_KEY=your_hyperliquid_private_key
WALLET_ADDRESS=your_wallet_address
PORT=3040
DB_FILE_NAME=./mydb.sqlite
```

**Важно:** `WALLET_ADDRESS` необходим для подписки на события заполнения ордеров и обновления ордеров.

## Запуск

```bash
# Разработка с hot reload
bun run dev

# Production
bun run start
```

## База данных

### Миграции

```bash
# Создать миграцию
bun run create-migration

# Применить миграции
bun run migrate

# Открыть Drizzle Studio
bun run studio
```

### Схема таблиц

**strategies** - стратегии грид-бота
- `id` (text, PK)
- `enabled` (boolean)
- `settings` (json) - grid, minPrice, maxPrice
- `margin` (real)
- `balance` (real)
- `deleted` (boolean)
- `createdAt` (text)
- `startedAt` (text)
- `description` (text)

**order_size_levels** - уровни размеров ордеров
- `id` (integer, PK)
- `strategyId` (text, FK → strategies.id)
- `levelStart` (integer)
- `levelEnd` (integer)
- `size` (real)

**positions** - открытые/закрытые позиции
- `id` (integer, PK)
- `strategyId` (text, FK → strategies.id)
- `size` (real)
- `status` ('OPENED' | 'CLOSED')
- `gridOpenPrice` (real) - целевой грид (по которому выставляли ордер)
- `avgOpenPrice` (real) - **фактическая** цена исполнения BUY ордера
- `gridClosePrice` (real)

**orders** - ордера на бирже
- `id` (integer, PK)
- `positionId` (integer, FK → positions.id)
- `size` (real)
- `side` ('BUY' | 'SELL')
- `status` ('OPENED' | 'CANCELLED' | 'FILLED' | 'PARTIALLY_FILLED')
- `averagePrice` (real) - при создании = целевая цена грида, при fill = фактическая цена исполнения
- `fee` (real)
- `closedPnl` (real)
- `createdAt` (text)
- `closedAt` (text)

**Важно:**
- `averagePrice` в orders:
  - При создании (`OPENED`) = целевая цена грида
  - При заполнении (`FILLED`) = фактическая цена исполнения (из `fill.px`)
- `avgOpenPrice` в positions - всегда фактическая цена исполнения BUY ордера
- `gridOpenPrice` в positions - всегда целевой грид (определяется по `order.averagePrice` ДО fill)

## TODO

- [x] Загрузка только открытых ордеров в память
- [x] Выставление только 2 BUY и 2 SELL ордеров
- [x] Подписка на filled события из WebSocket
- [x] Автоматическая синхронизация при заполнении ордера
- [x] При свежем старте выставляется 1 MARKET ордер с суммарным размером всех позиций
- [x] Рефакторинг: единая функция loadStrategy(strategyId | null)
- [x] Рефакторинг: единая функция startStrategy в StrategyRunner
- [x] Сохранение сервисных ордеров в памяти
- [x] Обработка заполнения сервисного ордера INITIAL_POSITIONS_BUY_UP
- [x] Создание позиций в БД при заполнении начального ордера
- [x] Диапазоны orderSizeLevels работают по ценам (levelEnd включается для последнего)
- [x] Рефакторинг: вынесены findBuyTargets и findSellTargets в StrategyService
- [x] Добавлен параметр numberOfOrders для настройки количества одновременных ордеров
- [x] Используется реальный размер купленной позиции при создании позиций (делится поровну)
- [x] findBuyTargets проверяет открытые BUY ордера (не выставляет дубликаты)
- [x] findSellTargets проверяет открытые SELL ордера (не выставляет дубликаты)
- [x] Добавлены функции getOrderIdFromStatus и getAllOrderIdsFromResponse для извлечения ID ордеров
- [x] Перенесена функция saveOrderToDB в StrategyService
- [x] Добавлена функция saveOpenedOrderToDB для сохранения открытых ордеров
- [x] Реализована обработка заполнения BUY ордеров (handleBuyOrderFill) - создает позиции
- [x] Реализована обработка заполнения SELL ордеров (handleSellOrderFill) - закрывает позиции
- [x] ID ордеров извлекаются из ответа биржи и сохраняются в БД при выставлении
- [x] Позиции создаются в БД при заполнении BUY ордера
- [x] Позиции закрываются в БД при заполнении SELL ордера
- [x] Рассчитывается и сохраняется PnL при закрытии позиций
- [x] Баланс обновляется при заполнении ордеров (комиссии и PnL)
- [x] Обработка всех filled событий в цикле (для множественных заполнений)
- [x] Группировка fills по oid для предотвращения дубликатов
- [x] Агрегация частичных заполнений (суммирование size, fee, средневзвешенная цена)
- [x] Проверка статуса ордера перед обработкой (пропускаем уже FILLED)
- [x] Добавлен параметр ensureMinimum для гарантии минимум 1 BUY + 1 SELL при старте
- [x] findSellTargets с fallback на любую позицию, если не нашли близко к цене
- [x] syncOrders вызывается с ensureMinimum=true при первом запуске стратегии
- [ ] Реализовать отмену ордеров через Hyperliquid SDK
- [ ] Обработать cancelled и filled статусы в handleOrderUpdates
- [ ] Реализовать обработку funding payments
- [ ] Добавить мониторинг PnL
- [ ] Добавить логирование всех операций в файл

